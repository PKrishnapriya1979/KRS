{"ast":null,"code":"export const sortRowTree = params => {\n  const {\n    rowIds,\n    rowTree,\n    disableChildrenSorting,\n    sortRowList\n  } = params;\n  let sortedRows = []; // Group the rows by parent\n\n  const groupedByParentRows = new Map([[null, []]]);\n\n  for (let i = 0; i < rowIds.length; i += 1) {\n    const rowId = rowIds[i];\n    const node = rowTree[rowId];\n    let group = groupedByParentRows.get(node.parent);\n\n    if (!group) {\n      group = [];\n      groupedByParentRows.set(node.parent, group);\n    }\n\n    group.push(node);\n  } // Apply the sorting to each list of children\n\n\n  const sortedGroupedByParentRows = new Map();\n  groupedByParentRows.forEach((rowList, parent) => {\n    if (rowList.length === 0) {\n      sortedGroupedByParentRows.set(parent, []);\n    } else {\n      const depth = rowList[0].depth;\n\n      if (depth > 0 && disableChildrenSorting) {\n        sortedGroupedByParentRows.set(parent, rowList.map(row => row.id));\n      } else if (!sortRowList) {\n        sortedGroupedByParentRows.set(parent, rowList.map(row => row.id));\n      } else {\n        sortedGroupedByParentRows.set(parent, sortRowList(rowList));\n      }\n    }\n  }); // Flatten the sorted lists to have children just after their parent\n\n  const insertRowListIntoSortedRows = (startIndex, rowList) => {\n    sortedRows = [...sortedRows.slice(0, startIndex), ...rowList, ...sortedRows.slice(startIndex)];\n    let treeSize = 0;\n    rowList.forEach(rowId => {\n      treeSize += 1;\n      const children = sortedGroupedByParentRows.get(rowId);\n\n      if (children != null && children.length) {\n        const subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(null));\n  return sortedRows;\n};","map":{"version":3,"sources":["C:/Users/Admin/Documents/KRS/Application1/client/node_modules/@mui/x-data-grid-pro/utils/tree/sortRowTree.js"],"names":["sortRowTree","params","rowIds","rowTree","disableChildrenSorting","sortRowList","sortedRows","groupedByParentRows","Map","i","length","rowId","node","group","get","parent","set","push","sortedGroupedByParentRows","forEach","rowList","depth","map","row","id","insertRowListIntoSortedRows","startIndex","slice","treeSize","children","subTreeSize"],"mappings":"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","sourcesContent":["export const sortRowTree = params => {\n  const {\n    rowIds,\n    rowTree,\n    disableChildrenSorting,\n    sortRowList\n  } = params;\n  let sortedRows = []; // Group the rows by parent\n\n  const groupedByParentRows = new Map([[null, []]]);\n\n  for (let i = 0; i < rowIds.length; i += 1) {\n    const rowId = rowIds[i];\n    const node = rowTree[rowId];\n    let group = groupedByParentRows.get(node.parent);\n\n    if (!group) {\n      group = [];\n      groupedByParentRows.set(node.parent, group);\n    }\n\n    group.push(node);\n  } // Apply the sorting to each list of children\n\n\n  const sortedGroupedByParentRows = new Map();\n  groupedByParentRows.forEach((rowList, parent) => {\n    if (rowList.length === 0) {\n      sortedGroupedByParentRows.set(parent, []);\n    } else {\n      const depth = rowList[0].depth;\n\n      if (depth > 0 && disableChildrenSorting) {\n        sortedGroupedByParentRows.set(parent, rowList.map(row => row.id));\n      } else if (!sortRowList) {\n        sortedGroupedByParentRows.set(parent, rowList.map(row => row.id));\n      } else {\n        sortedGroupedByParentRows.set(parent, sortRowList(rowList));\n      }\n    }\n  }); // Flatten the sorted lists to have children just after their parent\n\n  const insertRowListIntoSortedRows = (startIndex, rowList) => {\n    sortedRows = [...sortedRows.slice(0, startIndex), ...rowList, ...sortedRows.slice(startIndex)];\n    let treeSize = 0;\n    rowList.forEach(rowId => {\n      treeSize += 1;\n      const children = sortedGroupedByParentRows.get(rowId);\n\n      if (children != null && children.length) {\n        const subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(null));\n  return sortedRows;\n};"]},"metadata":{},"sourceType":"module"}