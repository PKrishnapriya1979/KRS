{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField;\n  const groupingField2 = cellParams2.rowNode.groupingField;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          // We only want to filter leaves\n          if (params.rowNode.groupingField != null) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.groupingField === null && cellParams2.rowNode.groupingField === null) {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          // We only want to filter the groups of the current grouping criteria\n          if (params.rowNode.groupingField !== groupedByColDef.field) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\n\n\nexport const createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n\n  var _groupedByColDef$widt, _leafColDef$width;\n\n  const _ref = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render leaves\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\n\nexport const createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n\n  var _leafColDef$width2;\n\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render the leaves\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      return params.rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":{"version":3,"sources":["C:/Users/Admin/Documents/KRS/Application1/client/node_modules/@mui/x-data-grid-pro/hooks/features/rowGrouping/createGroupingColDef.js"],"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","React","GRID_STRING_COL_DEF","GridGroupingCriteriaCell","GridGroupingColumnLeafCell","getRowGroupingFieldFromGroupingCriteria","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","gridRowGroupingSanitizedModelSelector","jsx","_jsx","GROUPING_COL_DEF_DEFAULT_PROPERTIES","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","type","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","model","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","_leafColDef$headerNam","_leafColDef$filterOpe","headerName","field","sortable","filterable","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","params","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","_groupedByColDef$filt","properties","_groupedByColDef$head","createGroupingColDefForOneGroupingCriteria","columnsLookup","groupingCriteria","colDefOverride","_groupedByColDef$widt","_leafColDef$width","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","leafParams","getCellParams","id","valueGetter","undefined","getCellValue","groupingKey","sourceProperties","forcedProperties","createGroupingColDefForAllGroupingCriteria","apiRef","rowGroupingModel","_leafColDef$width2","_ref2","current","getLocaleText","_columnsLookup$field$","includes","length"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField;\n  const groupingField2 = cellParams2.rowNode.groupingField;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          // We only want to filter leaves\n          if (params.rowNode.groupingField != null) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.groupingField === null && cellParams2.rowNode.groupingField === null) {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          // We only want to filter the groups of the current grouping criteria\n          if (params.rowNode.groupingField !== groupedByColDef.field) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n\n  return properties;\n};\n\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  var _groupedByColDef$widt, _leafColDef$width;\n\n  const _ref = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render leaves\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  var _leafColDef$width2;\n\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render the leaves\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      return params.rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};"]},"metadata":{},"sourceType":"module"}