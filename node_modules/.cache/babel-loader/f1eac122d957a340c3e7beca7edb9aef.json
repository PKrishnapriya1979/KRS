{"ast":null,"code":"export const TREE_DATA_STRATEGY = 'tree-data';\n/**\n * A node is visible if one of the following criteria is met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\nexport const filterRowTreeFromTreeData = params => {\n  const {\n    rowTree,\n    disableChildrenFiltering,\n    isRowMatchingFilters\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, isParentMatchingFilters, areAncestorsExpanded) => {\n    var _node$children;\n\n    const shouldSkipFilters = disableChildrenFiltering && node.depth > 0;\n    let isMatchingFilters;\n\n    if (shouldSkipFilters) {\n      isMatchingFilters = null;\n    } else if (!isRowMatchingFilters) {\n      isMatchingFilters = true;\n    } else {\n      isMatchingFilters = isRowMatchingFilters(node.id);\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      var _isMatchingFilters;\n\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, (_isMatchingFilters = isMatchingFilters) != null ? _isMatchingFilters : isParentMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);\n      filteredDescendantCount += childSubTreeSize;\n    });\n    let shouldPassFilters;\n\n    switch (isMatchingFilters) {\n      case true:\n        {\n          shouldPassFilters = true;\n          break;\n        }\n\n      case false:\n        {\n          shouldPassFilters = filteredDescendantCount > 0;\n          break;\n        }\n\n      default:\n        {\n          shouldPassFilters = isParentMatchingFilters;\n          break;\n        }\n    }\n\n    visibleRowsLookup[node.id] = shouldPassFilters && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = shouldPassFilters;\n\n    if (!shouldPassFilters) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n    return filteredDescendantCount + 1;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, true);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};","map":{"version":3,"sources":["C:/Users/Admin/Documents/KRS/Application1/client/node_modules/@mui/x-data-grid-pro/hooks/features/treeData/gridTreeDataUtils.js"],"names":["TREE_DATA_STRATEGY","filterRowTreeFromTreeData","params","rowTree","disableChildrenFiltering","isRowMatchingFilters","visibleRowsLookup","filteredRowsLookup","filteredDescendantCountLookup","filterTreeNode","node","isParentMatchingFilters","areAncestorsExpanded","_node$children","shouldSkipFilters","depth","isMatchingFilters","id","filteredDescendantCount","children","forEach","childId","_isMatchingFilters","childNode","childSubTreeSize","childrenExpanded","shouldPassFilters","nodes","Object","values","i","length"],"mappings":"AAAA,OAAO,MAAMA,kBAAkB,GAAG,WAA3B;AACP;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,yBAAyB,GAAGC,MAAM,IAAI;AACjD,QAAM;AACJC,IAAAA,OADI;AAEJC,IAAAA,wBAFI;AAGJC,IAAAA;AAHI,MAIFH,MAJJ;AAKA,QAAMI,iBAAiB,GAAG,EAA1B;AACA,QAAMC,kBAAkB,GAAG,EAA3B;AACA,QAAMC,6BAA6B,GAAG,EAAtC;;AAEA,QAAMC,cAAc,GAAG,CAACC,IAAD,EAAOC,uBAAP,EAAgCC,oBAAhC,KAAyD;AAC9E,QAAIC,cAAJ;;AAEA,UAAMC,iBAAiB,GAAGV,wBAAwB,IAAIM,IAAI,CAACK,KAAL,GAAa,CAAnE;AACA,QAAIC,iBAAJ;;AAEA,QAAIF,iBAAJ,EAAuB;AACrBE,MAAAA,iBAAiB,GAAG,IAApB;AACD,KAFD,MAEO,IAAI,CAACX,oBAAL,EAA2B;AAChCW,MAAAA,iBAAiB,GAAG,IAApB;AACD,KAFM,MAEA;AACLA,MAAAA,iBAAiB,GAAGX,oBAAoB,CAACK,IAAI,CAACO,EAAN,CAAxC;AACD;;AAED,QAAIC,uBAAuB,GAAG,CAA9B;AACA,KAACL,cAAc,GAAGH,IAAI,CAACS,QAAvB,KAAoC,IAApC,GAA2C,KAAK,CAAhD,GAAoDN,cAAc,CAACO,OAAf,CAAuBC,OAAO,IAAI;AACpF,UAAIC,kBAAJ;;AAEA,YAAMC,SAAS,GAAGpB,OAAO,CAACkB,OAAD,CAAzB;AACA,YAAMG,gBAAgB,GAAGf,cAAc,CAACc,SAAD,EAAY,CAACD,kBAAkB,GAAGN,iBAAtB,KAA4C,IAA5C,GAAmDM,kBAAnD,GAAwEX,uBAApF,EAA6GC,oBAAoB,IAAI,CAAC,CAACF,IAAI,CAACe,gBAA5I,CAAvC;AACAP,MAAAA,uBAAuB,IAAIM,gBAA3B;AACD,KANmD,CAApD;AAOA,QAAIE,iBAAJ;;AAEA,YAAQV,iBAAR;AACE,WAAK,IAAL;AACE;AACEU,UAAAA,iBAAiB,GAAG,IAApB;AACA;AACD;;AAEH,WAAK,KAAL;AACE;AACEA,UAAAA,iBAAiB,GAAGR,uBAAuB,GAAG,CAA9C;AACA;AACD;;AAEH;AACE;AACEQ,UAAAA,iBAAiB,GAAGf,uBAApB;AACA;AACD;AAjBL;;AAoBAL,IAAAA,iBAAiB,CAACI,IAAI,CAACO,EAAN,CAAjB,GAA6BS,iBAAiB,IAAId,oBAAlD;AACAL,IAAAA,kBAAkB,CAACG,IAAI,CAACO,EAAN,CAAlB,GAA8BS,iBAA9B;;AAEA,QAAI,CAACA,iBAAL,EAAwB;AACtB,aAAO,CAAP;AACD;;AAEDlB,IAAAA,6BAA6B,CAACE,IAAI,CAACO,EAAN,CAA7B,GAAyCC,uBAAzC;AACA,WAAOA,uBAAuB,GAAG,CAAjC;AACD,GArDD;;AAuDA,QAAMS,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc1B,OAAd,CAAd;;AAEA,OAAK,IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,IAAI,CAAvC,EAA0C;AACxC,UAAMpB,IAAI,GAAGiB,KAAK,CAACG,CAAD,CAAlB;;AAEA,QAAIpB,IAAI,CAACK,KAAL,KAAe,CAAnB,EAAsB;AACpBN,MAAAA,cAAc,CAACC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAd;AACD;AACF;;AAED,SAAO;AACLJ,IAAAA,iBADK;AAELC,IAAAA,kBAFK;AAGLC,IAAAA;AAHK,GAAP;AAKD,CAhFM","sourcesContent":["export const TREE_DATA_STRATEGY = 'tree-data';\n/**\n * A node is visible if one of the following criteria is met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\nexport const filterRowTreeFromTreeData = params => {\n  const {\n    rowTree,\n    disableChildrenFiltering,\n    isRowMatchingFilters\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, isParentMatchingFilters, areAncestorsExpanded) => {\n    var _node$children;\n\n    const shouldSkipFilters = disableChildrenFiltering && node.depth > 0;\n    let isMatchingFilters;\n\n    if (shouldSkipFilters) {\n      isMatchingFilters = null;\n    } else if (!isRowMatchingFilters) {\n      isMatchingFilters = true;\n    } else {\n      isMatchingFilters = isRowMatchingFilters(node.id);\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      var _isMatchingFilters;\n\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, (_isMatchingFilters = isMatchingFilters) != null ? _isMatchingFilters : isParentMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);\n      filteredDescendantCount += childSubTreeSize;\n    });\n    let shouldPassFilters;\n\n    switch (isMatchingFilters) {\n      case true:\n        {\n          shouldPassFilters = true;\n          break;\n        }\n\n      case false:\n        {\n          shouldPassFilters = filteredDescendantCount > 0;\n          break;\n        }\n\n      default:\n        {\n          shouldPassFilters = isParentMatchingFilters;\n          break;\n        }\n    }\n\n    visibleRowsLookup[node.id] = shouldPassFilters && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = shouldPassFilters;\n\n    if (!shouldPassFilters) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n    return filteredDescendantCount + 1;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, true);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};"]},"metadata":{},"sourceType":"module"}