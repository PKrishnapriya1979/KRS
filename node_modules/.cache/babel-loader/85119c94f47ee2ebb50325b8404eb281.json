{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nexport const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nexport const ROW_GROUPING_STRATEGY = 'grouping-columns';\nexport const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexport const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\nexport const isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\n\nconst shouldApplyFilterItemOnGroup = (item, node) => {\n  if (item.columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(item.columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nexport const filterRowTreeFromGroupingColumns = params => {\n  const {\n    rowTree,\n    isRowMatchingFilters\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, areAncestorsPassingChildren, areAncestorsExpanded) => {\n    var _node$children, _node$children2;\n\n    let isMatchingFilters;\n\n    if (!isRowMatchingFilters) {\n      isMatchingFilters = true;\n    } else {\n      const shouldApplyItem = node.isAutoGenerated ? item => shouldApplyFilterItemOnGroup(item, node) : undefined;\n      isMatchingFilters = isRowMatchingFilters(node.id, shouldApplyItem);\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, areAncestorsPassingChildren && isMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);\n      filteredDescendantCount += childSubTreeSize;\n    });\n    let shouldPassFilters;\n\n    if (!areAncestorsPassingChildren) {\n      shouldPassFilters = false;\n    } else if ((_node$children2 = node.children) != null && _node$children2.length) {\n      shouldPassFilters = isMatchingFilters && filteredDescendantCount > 0;\n    } else {\n      shouldPassFilters = isMatchingFilters;\n    }\n\n    visibleRowsLookup[node.id] = shouldPassFilters && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = shouldPassFilters;\n\n    if (!shouldPassFilters) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (!node.children) {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, true);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexport const getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\nexport const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {\n  rowGrouping: _extends({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexport const setStrategyAvailability = (apiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};","map":{"version":3,"sources":["C:/Users/Admin/Documents/KRS/Application1/client/node_modules/@mui/x-data-grid-pro/hooks/features/rowGrouping/gridRowGroupingUtils.js"],"names":["_extends","gridRowGroupingSanitizedModelSelector","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","ROW_GROUPING_STRATEGY","getRowGroupingFieldFromGroupingCriteria","groupingCriteria","getRowGroupingCriteriaFromGroupingField","groupingColDefField","match","isGroupingColumn","field","shouldApplyFilterItemOnGroup","item","node","columnField","groupingCriteriaField","groupingField","filterRowTreeFromGroupingColumns","params","rowTree","isRowMatchingFilters","visibleRowsLookup","filteredRowsLookup","filteredDescendantCountLookup","filterTreeNode","areAncestorsPassingChildren","areAncestorsExpanded","_node$children","_node$children2","isMatchingFilters","shouldApplyItem","isAutoGenerated","undefined","id","filteredDescendantCount","children","forEach","childId","childNode","childSubTreeSize","childrenExpanded","shouldPassFilters","length","nodes","Object","values","i","depth","getColDefOverrides","groupingColDefProp","fields","groupingName","mergeStateWithRowGroupingModel","rowGroupingModel","state","rowGrouping","model","setStrategyAvailability","apiRef","disableRowGrouping","isAvailable","rowGroupingSanitizedModel","current","unstable_setStrategyAvailability"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nexport const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nexport const ROW_GROUPING_STRATEGY = 'grouping-columns';\nexport const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexport const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\nexport const isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\nconst shouldApplyFilterItemOnGroup = (item, node) => {\n  if (item.columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(item.columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nexport const filterRowTreeFromGroupingColumns = params => {\n  const {\n    rowTree,\n    isRowMatchingFilters\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, areAncestorsPassingChildren, areAncestorsExpanded) => {\n    var _node$children, _node$children2;\n\n    let isMatchingFilters;\n\n    if (!isRowMatchingFilters) {\n      isMatchingFilters = true;\n    } else {\n      const shouldApplyItem = node.isAutoGenerated ? item => shouldApplyFilterItemOnGroup(item, node) : undefined;\n      isMatchingFilters = isRowMatchingFilters(node.id, shouldApplyItem);\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, areAncestorsPassingChildren && isMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);\n      filteredDescendantCount += childSubTreeSize;\n    });\n    let shouldPassFilters;\n\n    if (!areAncestorsPassingChildren) {\n      shouldPassFilters = false;\n    } else if ((_node$children2 = node.children) != null && _node$children2.length) {\n      shouldPassFilters = isMatchingFilters && filteredDescendantCount > 0;\n    } else {\n      shouldPassFilters = isMatchingFilters;\n    }\n\n    visibleRowsLookup[node.id] = shouldPassFilters && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = shouldPassFilters;\n\n    if (!shouldPassFilters) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (!node.children) {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, true);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexport const getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\nexport const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {\n  rowGrouping: _extends({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexport const setStrategyAvailability = (apiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};"]},"metadata":{},"sourceType":"module"}