{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = `auto-generated-row-${row.path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).slice(0, depth + 1).join('-')}`;\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    groupingName: params.groupingName\n  };\n};","map":{"version":3,"sources":["C:/Users/Admin/Documents/KRS/Application1/client/node_modules/@mui/x-data-grid-pro/utils/tree/buildRowTree.js"],"names":["_extends","buildRowTree","params","tempTree","treeDepth","ids","idRowsLookup","groupingCriteriaToIdTree","isGroupExpandedByDefault","node","_params$previousTree","_params$previousTree$","previousExpansion","previousTree","id","childrenExpanded","children","length","undefined","defaultGroupingExpansionDepth","depth","i","rows","row","keyToIdSubTree","parentNode","path","key","field","rawField","nodeId","fieldSubTree","keyConfig","toString","_params$onDuplicatePa","onDuplicatePath","call","map","groupingCriteria","slice","join","_parentNode$id","_parentNode","isAutoGenerated","parent","groupingKey","groupingField","push","Math","max","tree","_params$previousTree2","_previousNode$childre","_node$children","_previousNode$childre2","rowId","tempNode","nodeWithoutChildrenExpansion","Object","values","previousNode","shouldReUsePreviousNode","every","childId","index","_node$children2","groupingName"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = `auto-generated-row-${row.path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).slice(0, depth + 1).join('-')}`;\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    groupingName: params.groupingName\n  };\n};"]},"metadata":{},"sourceType":"module"}